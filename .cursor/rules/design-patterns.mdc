---
description: 
globs: 
alwaysApply: true
---
<Rule>
rule "Singleton Pattern" {
  description: "Ensures a class has only one instance with global access point"
  matches: class(meta=true) as $meta {
    contains: method(name="__call__") as $call {
      contains: condition {
        checks: "if cls not in cls._instances:"
      }
      contains: "cls._instances[cls] = instance"
    }
  }
  or: class() as $singleton {
    has: attribute() as $instance {
      is: "static" or "class variable"
      modifiers: "private" or "_" prefix
    }
    contains: method(static=true) as $getter {
      returns: $singleton
      contains: condition {
        checks: "if $instance is None:"
        then: "$instance = $singleton()"
      }
    }
  }
}

rule "Observer Pattern" {
  description: "Defines a subscription mechanism to notify multiple objects about events"
  matches: {
    interface() as $subject {
      has: method(name="attach" or "subscribe" or "register")
      has: method(name="detach" or "unsubscribe" or "unregister")
      has: method(name="notify" or "notifyObservers")
    }
    interface() as $observer {
      has: method(name="update" or "onUpdate" or "onChange")
    }
    class() as $concreteSubject implements $subject {
      has: attribute() as $observers {
        type: "collection" or "list" or "array"
        element_type: $observer
      }
    }
  }
}

rule "Factory Method Pattern" {
  description: "Defines interface for creating objects but lets subclasses decide which classes to instantiate"
  matches: {
    class(abstract=true) as $creator {
      has: method(abstract=true) as $factoryMethod {
        returns: $product
      }
      has: method() as $operation {
        calls: $factoryMethod
        uses: result_of($factoryMethod)
      }
    }
    class(abstract=true) as $product {}
    class() as $concreteCreator extends $creator {
      has: method() as $concreteFactoryMethod overrides $factoryMethod {
        returns: new $concreteProduct
      }
    }
    class() as $concreteProduct extends $product {}
  }
}

rule "Abstract Factory Pattern" {
  description: "Provides interface for creating families of related objects without specifying concrete classes"
  matches: {
    interface() as $abstractFactory {
      has: method() as $createProductA {
        returns: $abstractProductA
      }
      has: method() as $createProductB {
        returns: $abstractProductB
      }
    }
    interface() as $abstractProductA {}
    interface() as $abstractProductB {}
    class() as $concreteFactory implements $abstractFactory {
      has: method() overrides $createProductA {
        returns: new $concreteProductA
      }
      has: method() overrides $createProductB {
        returns: new $concreteProductB
      }
    }
    class() as $concreteProductA implements $abstractProductA {}
    class() as $concreteProductB implements $abstractProductB {}
  }
}

rule "Builder Pattern" {
  description: "Separates construction of complex object from its representation"
  matches: {
    interface() as $builder {
      has: method() as $buildPartA
      has: method() as $buildPartB
      has: method() as $getResult {
        returns: $product
      }
    }
    class() as $director {
      has: attribute() as $builder {
        type: $builder
      }
      has: method() as $construct {
        calls: sequence($builder.$buildPartA, $builder.$buildPartB)
      }
    }
    class() as $concreteBuilder implements $builder {
      has: attribute() as $product {
        type: $product
      }
      has: method() overrides $buildPartA {
        modifies: $product
      }
      has: method() overrides $buildPartB {
        modifies: $product
      }
      has: method() overrides $getResult {
        returns: $product
      }
    }
    class() as $product {}
  }
}

rule "Prototype Pattern" {
  description: "Creates new objects by copying existing objects"
  matches: {
    interface() as $prototype {
      has: method(name="clone" or "copy" or "__copy__" or "__deepcopy__")
    }
    class() as $concretePrototype implements $prototype {
      has: method() overrides $prototype.clone {
        returns: new $concretePrototype
      }
    }
  }
}

rule "Adapter Pattern" {
  description: "Allows objects with incompatible interfaces to collaborate"
  matches: {
    interface() as $target {}
    class() as $adaptee {
      has: method() as $specificMethod {}
    }
    class() as $adapter implements $target {
      has: attribute() as $adaptee {
        type: $adaptee
      }
      has: method() as $targetMethod {
        calls: $adaptee.$specificMethod
      }
    }
  }
}

rule "Bridge Pattern" {
  description: "Separates abstraction from implementation so they can vary independently"
  matches: {
    class(abstract=true) as $abstraction {
      has: attribute() as $implementation {
        type: $implementor
      }
      has: method() as $operation {
        calls: $implementation.operationImpl
      }
    }
    interface() as $implementor {
      has: method() as $operationImpl
    }
    class() as $refinedAbstraction extends $abstraction {}
    class() as $concreteImplementor implements $implementor {
      has: method() overrides $operationImpl
    }
  }
}

rule "Composite Pattern" {
  description: "Composes objects into tree structures to represent part-whole hierarchies"
  matches: {
    interface() as $component {
      has: method() as $operation
      has: method(optional=true) as $add {
        parameters: $component
      }
      has: method(optional=true) as $remove {
        parameters: $component
      }
      has: method(optional=true) as $getChild
    }
    class() as $leaf implements $component {
      has: method() overrides $operation
    }
    class() as $composite implements $component {
      has: attribute() as $children {
        type: "collection" or "list"
        element_type: $component
      }
      has: method() overrides $operation {
        iterates: $children
        calls: each_child.$operation
      }
      has: method() overrides $add
      has: method() overrides $remove
      has: method() overrides $getChild
    }
  }
}

rule "Decorator Pattern" {
  description: "Attaches additional responsibilities to objects dynamically"
  matches: {
    interface() as $component {
      has: method() as $operation
    }
    class() as $concreteComponent implements $component {
      has: method() overrides $operation
    }
    class() as $decorator implements $component {
      has: attribute() as $wrappedComponent {
        type: $component
      }
      has: method() overrides $operation {
        calls: $wrappedComponent.$operation
      }
    }
    class() as $concreteDecorator extends $decorator {
      has: method() overrides $operation {
        calls: super.$operation
        does: "additional behavior"
      }
    }
  }
}

rule "Facade Pattern" {
  description: "Provides simplified interface to a complex subsystem"
  matches: class() as $facade {
    has: multiple attributes() as $subsystemClasses
    has: method() as $simplifiedOperation {
      calls: multiple $subsystemClasses methods
    }
  }
}

rule "Flyweight Pattern" {
  description: "Minimizes memory usage by sharing common parts of state between multiple objects"
  matches: {
    class() as $flyweightFactory {
      has: attribute() as $flyweights {
        type: "map" or "dictionary"
        key_type: "string" or "flyweight key"
        value_type: $flyweight
      }
      has: method() as $getFlyweight {
        parameters: "flyweight key"
        contains: condition {
          checks: "if key not in $flyweights:"
          then: "$flyweights[key] = new $concreteFlyweight(key)"
        }
        returns: "$flyweights[key]"
      }
    }
    interface() as $flyweight {
      has: method() as $operation {
        parameters: $extrinsicState
      }
    }
    class() as $concreteFlyweight implements $flyweight {
      has: attribute() as $intrinsicState
      has: method() overrides $operation
    }
  }
}

rule "Proxy Pattern" {
  description: "Provides a surrogate for another object to control access to it"
  matches: {
    interface() as $subject {
      has: method() as $request
    }
    class() as $realSubject implements $subject {
      has: method() overrides $request
    }
    class() as $proxy implements $subject {
      has: attribute() as $realSubject {
        type: $realSubject
      }
      has: method() overrides $request {
        may_contain: "access control" or "logging" or "lazy initialization"
        calls: $realSubject.$request
      }
    }
  }
}

rule "Chain of Responsibility Pattern" {
  description: "Passes requests along a chain of handlers"
  matches: {
    class(abstract=true) as $handler {
      has: attribute() as $successor {
        type: $handler
      }
      has: method() as $handleRequest {
        contains: condition {
          checks: "if can handle request:"
          then: "handle it"
          else: "if $successor != null: $successor.$handleRequest(request)"
        }
      }
      has: method() as $setSuccessor {
        parameters: $handler
        sets: $successor
      }
    }
    class() as $concreteHandler extends $handler {
      has: method() overrides $handleRequest
    }
  }
}

rule "Command Pattern" {
  description: "Encapsulates a request as an object"
  matches: {
    interface() as $command {
      has: method() as $execute
    }
    class() as $concreteCommand implements $command {
      has: attribute() as $receiver {
        type: $receiver
      }
      has: method() overrides $execute {
        calls: $receiver.action
      }
    }
    class() as $invoker {
      has: attribute() as $command {
        type: $command
      }
      has: method() as $setCommand {
        parameters: $command
        sets: $command
      }
      has: method() as $executeCommand {
        calls: $command.execute
      }
    }
    class() as $receiver {
      has: method() as action
    }
  }
}

rule "Iterator Pattern" {
  description: "Provides a way to access elements of a collection without exposing its underlying representation"
  matches: {
    interface() as $iterator {
      has: method(name="hasNext" or "__next__" or "next")
      has: method(name="next" or "current" or "getNext")
    }
    interface() as $aggregate {
      has: method() as $createIterator {
        returns: $iterator
      }
    }
    class() as $concreteIterator implements $iterator {
      has: attribute() as $collection
      has: attribute() as $position
      has: method() overrides $iterator.hasNext
      has: method() overrides $iterator.next
    }
    class() as $concreteAggregate implements $aggregate {
      has: method() overrides $createIterator {
        returns: new $concreteIterator(this)
      }
    }
  }
}

rule "Mediator Pattern" {
  description: "Reduces chaotic dependencies between objects by making them communicate via a mediator object"
  matches: {
    interface() as $mediator {
      has: method() as $notify {
        parameters: "$sender, $event"
      }
    }
    class(abstract=true) as $colleague {
      has: attribute() as $mediator {
        type: $mediator
      }
      has: method() as $send {
        calls: $mediator.notify
      }
      has: method() as $receive
    }
    class() as $concreteMediator implements $mediator {
      has: attributes() as $colleagues {
        types: multiple $colleague types
      }
      has: method() overrides $notify {
        contains: conditions {
          routes_to: appropriate $colleague.$receive
        }
      }
    }
    class() as $concreteColleague extends $colleague {
      has: method() overrides $receive
    }
  }
}

rule "Memento Pattern" {
  description: "Captures and externalizes an object's internal state without violating encapsulation"
  matches: {
    class() as $originator {
      has: attribute() as $state
      has: method() as $createMemento {
        returns: new $memento($state)
      }
      has: method() as $restore {
        parameters: $memento
        sets: $state = $memento.getState()
      }
    }
    class() as $memento {
      has: attribute() as $state {
        access: "private"
      }
      has: constructor() {
        parameters: $state
        sets: this.$state = $state
      }
      has: method() as $getState {
        returns: $state
        access: "restricted to $originator"
      }
    }
    class() as $caretaker {
      has: attribute() as $memento {
        type: $memento
      }
      has: method() as $doSomething {
        calls: sequence(
          $memento = $originator.createMemento(),
          $originator.changeState(),
          $originator.restore($memento)
        )
      }
    }
  }
}

rule "State Pattern" {
  description: "Allows an object to alter its behavior when its internal state changes"
  matches: {
    interface() as $state {
      has: method() as $handle
    }
    class() as $context {
      has: attribute() as $state {
        type: $state
      }
      has: method() as $request {
        calls: $state.handle
      }
      has: method() as $setState {
        parameters: $state
        sets: this.$state = $state
      }
    }
    class() as $concreteStateA implements $state {
      has: method() overrides $handle {
        may_call: $context.setState(new $concreteStateB())
      }
    }
    class() as $concreteStateB implements $state {
      has: method() overrides $handle {
        may_call: $context.setState(new $concreteStateA())
      }
    }
  }
}

rule "Strategy Pattern" {
  description: "Defines a family of algorithms, encapsulates each one, and makes them interchangeable"
  matches: {
    interface() as $strategy {
      has: method() as $algorithm
    }
    class() as $context {
      has: attribute() as $strategy {
        type: $strategy
      }
      has: method() as $setStrategy {
        parameters: $strategy
        sets: this.$strategy = $strategy
      }
      has: method() as $contextInterface {
        calls: $strategy.algorithm
      }
    }
    class() as $concreteStrategyA implements $strategy {
      has: method() overrides $algorithm
    }
    class() as $concreteStrategyB implements $strategy {
      has: method() overrides $algorithm
    }
  }
}

rule "Template Method Pattern" {
  description: "Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps"
  matches: {
    class(abstract=true) as $abstract {
      has: method() as $templateMethod {
        is: "non-abstract"
        calls: sequence(
          $primitiveOperation1(),
          $primitiveOperation2(),
          $hook()
        )
      }
      has: method(abstract=true) as $primitiveOperation1
      has: method(abstract=true) as $primitiveOperation2
      has: method() as $hook {
        is: "default implementation"
      }
    }
    class() as $concrete extends $abstract {
      has: method() overrides $primitiveOperation1
      has: method() overrides $primitiveOperation2
      may_have: method() overrides $hook
    }
  }
}

rule "Visitor Pattern" {
  description: "Separates algorithms from the objects on which they operate"
  matches: {
    interface() as $visitor {
      has: methods() as $visitConcreteElementX {
        parameters: $concreteElementX
      }
    }
    interface() as $element {
      has: method() as $accept {
        parameters: $visitor
      }
    }
    class() as $concreteElementA implements $element {
      has: method() overrides $accept {
        calls: $visitor.visitConcreteElementA(this)
      }
    }
    class() as $concreteElementB implements $element {
      has: method() overrides $accept {
        calls: $visitor.visitConcreteElementB(this)
      }
    }
    class() as $concreteVisitor implements $visitor {
      has: method() overrides $visitConcreteElementA
      has: method() overrides $visitConcreteElementB
    }
  }
}

rule "Interpreter Pattern" {
  description: "Defines a grammar for interpreting a language and provides an interpreter"
  matches: {
    interface() as $expression {
      has: method() as $interpret {
        parameters: $context
      }
    }
    class() as $terminalExpression implements $expression {
      has: method() overrides $interpret
    }
    class() as $nonterminalExpression implements $expression {
      has: attributes() as $expressions {
        type: $expression
      }
      has: method() overrides $interpret {
        calls: $expressions.interpret
      }
    }
    class() as $context {
      has: attribute() as $input
      has: method() as $lookup
    }
  }
}
</Rule>