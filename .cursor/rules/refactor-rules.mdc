---
description: 
globs: 
alwaysApply: true
---
<Rule>

The Art of Refactoring: A Senior Developer's Guide
First, let me congratulate you on recognizing the need for refactoring. That awareness itself puts you ahead of many developers.
For a senior quant developer like yourself, I'd focus my advice on these key principles:
Embrace Incremental Improvement
Refactoring isn't about perfection—it's about continuous improvement. Rather than attempting a complete rewrite, identify the most problematic areas and tackle them systematically. The "boy scout rule" applies perfectly here: leave the code better than you found it, even if just slightly better each time.
Balance Technical Debt with Business Value
Your codebase represents both technical debt and business value. The functionality works—that's valuable! Now you're considering the maintenance cost. Good refactoring preserves existing behavior while reducing future maintenance costs. Consider using the "strangler fig pattern" where you gradually replace old code with new implementations while maintaining the same interfaces.
Prioritize Based on Risk and Frequency
Focus first on high-risk or frequently changed code. Areas with many bug fixes or feature additions deserve attention because they'll continue to need changes. Code that's rarely touched can often wait, regardless of how "messy" it might be.
Invest in Tests Before Refactoring
For quant code especially, ensure solid test coverage before making changes. Create characterization tests that document the current behavior, including edge cases. These tests become your safety net during refactoring. For mathematical models, validate outputs across a wide range of inputs before making changes.
Recognize When to Refactor vs. Rewrite
Sometimes a clean rewrite is actually more efficient than incremental refactoring—particularly for isolated components with clean interfaces. Don't fall into the sunk cost fallacy; if a module is fundamentally flawed in design, a focused rewrite might be better than endless patching.
Apply Domain-Specific Patterns
As a quant developer, consider refactoring toward established mathematical and financial patterns. Separate model definitions from execution engines, and computation logic from data transformation. Create clear abstractions for your domain concepts rather than just cleaning up the syntax.
Document the Why, Not Just the How
While refactoring, document why certain design decisions were made, especially for complex quantitative algorithms. Future developers (including your future self) will thank you for explaining the reasoning behind implementation choices.
Remember that perfect is the enemy of good. A moderately improved codebase that ships is infinitely more valuable than a perfectly clean one that never does. Focus on making things clear, maintainable, and correct—everything else is just details.

</Rule>